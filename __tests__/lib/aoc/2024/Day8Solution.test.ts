import Day8Solution from "@solutions/2024/Day8Solution";
import Matrix from "@solutions/Matrix";

const input = `............
........0...
.....0......
.......0....
....0.......
......A.....
............
............
........A...
.........A..
............
............`;

describe("Day 8 Solution", () => {
  let solution: Day8Solution;

  beforeEach(() => {
    solution = new Day8Solution(input);
  });

  it("should have DAY == 8", () => {
    expect(solution.DAY).toEqual(8);
  });

  it("should have matrix", () => {
    expect(solution.matrix).toBeInstanceOf(Matrix);
  });

  it("should have nodeMap with unique keys equal to matrix node strings and values equal to the coordinates of every instance of that node in the matrix", () => {
    expect(solution.nodeMap.has("0")).toBe(true);
    expect(solution.nodeMap.get("0")).toEqual(
      expect.arrayContaining([
        [1, 8],
        [2, 5],
        [3, 7],
        [4, 4],
      ])
    );
    expect(solution.nodeMap.has("A")).toBe(true);
    expect(solution.nodeMap.get("A")).toEqual(
      expect.arrayContaining([
        [8, 8],
        [9, 9],
        [5, 6],
      ])
    );
  });

  it("should have static entryDistance method that returns the distance between two cells", () => {
    expect(Day8Solution.entryDistance([1, 8], [2, 5])).toEqual([1, -3]);
    expect(Day8Solution.entryDistance([2, 5], [1, 8])).toEqual([-1, 3]);
  });

  it("should have getAntinodes method that takes a pair of matrix coordinates and returns an array of the 0-2 inbounds coordinates of their antinodes", () => {
    expect(solution.getAntinodes([1, 8], [2, 5])).toEqual(
      expect.arrayContaining([
        [0, 11],
        [3, 2],
      ])
    );
    expect(solution.getAntinodes([0, 2], [2, 2])).toEqual(
      expect.arrayContaining([[4, 2]])
    );
    expect(solution.getAntinodes([0, 0], [11, 11])).toEqual([]);
  });

  it("should have set uniqueAntinodes", () => {
    expect(solution.uniqueAntinodes.has("3,2")).toBe(true);
    expect(solution.uniqueAntinodes.has("10,10")).toBe(true);
  });

  it("should have an accessor numUniqueAntinodes to return the number of unqiue antinodes generated by the input", () => {
    expect(solution.numUniqueAntinodes).toEqual(14);
  });

  it("should have getExtendedAntinodes method that gets all collinear and equidistant antinodes of a given pair of coordinates", () => {
    expect(solution.getExtendedAntinodes([8, 8], [9, 9])).toEqual(
      expect.arrayContaining([
        [0, 0],
        [1, 1],
        [2, 2],
        [3, 3],
        [4, 4],
        [5, 5],
        [6, 6],
        [7, 7],
        [8, 8],
        [9, 9],
        [10, 10],
        [11, 11],
      ])
    );
  });

  it("should have set extendedUniqueAntinodes consisting of all points collinear and equidistant from all matching pairs in matrix", () => {
    expect(solution.extendedUniqueAntinodes.has("3,2")).toBe(true);
  });

  it("should have an accessor numExtendedUniqueAntinodes return the number of unique extended antinodes", () => {
    expect(solution.numExtendedUniqueAntinodes).toEqual(34);
  });
});
